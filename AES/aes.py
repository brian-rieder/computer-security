#!/usr/bin/env python2.7

# AES Encryption
# By: Brian Rieder

__author__ = 'brieder'

from BitVector import *

AES_modulus = BitVector(bitstring='100011011')

# The following two tables are generated by the genTables function. As they are constant regardless of input, they have
# been defined as constants for the sake of computational speed.
subBytesTable = [ 99, 124, 119, 123, 242, 107, 111, 197,  48,   1, 103,  43, 254, 215, 171, 118, 202, 130, 201, 125,
                 250,  89,  71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147,  38,  54,  63, 247, 204,
                  52, 165, 229, 241, 113, 216,  49,  21,   4, 199,  35, 195,  24, 150,   5, 154,   7,  18, 128, 226,
                 235,  39, 178, 117,   9, 131,  44,  26,  27, 110,  90, 160,  82,  59, 214, 179,  41, 227,  47, 132,
                  83, 209,   0, 237,  32, 252, 177,  91, 106, 203, 190,  57,  74,  76,  88, 207, 208, 239, 170, 251,
                  67,  77,  51, 133,  69, 249,   2, 127,  80,  60, 159, 168,  81, 163,  64, 143, 146, 157,  56, 245,
                 188, 182, 218,  33,  16, 255, 243, 210, 205,  12,  19, 236,  95, 151,  68,  23, 196, 167, 126,  61,
                 100,  93,  25, 115,  96, 129,  79, 220,  34,  42, 144, 136,  70, 238, 184,  20, 222,  94,  11, 219,
                 224,  50,  58,  10,  73,   6,  36,  92, 194, 211, 172,  98, 145, 149, 228, 121, 231, 200,  55, 109,
                 141, 213,  78, 169, 108,  86, 244, 234, 101, 122, 174,   8, 186, 120,  37,  46,  28, 166, 180, 198,
                 232, 221, 116,  31,  75, 189, 139, 138, 112,  62, 181, 102,  72,   3, 246,  14,  97,  53,  87, 185,
                 134, 193,  29, 158, 225, 248, 152,  17, 105, 217, 142, 148, 155,  30, 135, 233, 206,  85,  40, 223,
                 140, 161, 137,  13, 191, 230,  66, 104,  65, 153,  45,  15, 176,  84, 187,  22]
invSubBytesTable = [ 82,   9, 106, 213,  48,  54, 165,  56, 191,  64, 163, 158, 129, 243, 215, 251, 124, 227,  57, 130,
                    155,  47, 255, 135,  52, 142,  67,  68, 196, 222, 233, 203,  84, 123, 148,  50, 166, 194,  35,  61,
                    238,  76, 149,  11,  66, 250, 195,  78,   8,  46, 161, 102,  40, 217,  36, 178, 118,  91, 162,  73,
                    109, 139, 209,  37, 114, 248, 246, 100, 134, 104, 152,  22, 212, 164,  92, 204,  93, 101, 182, 146,
                    108, 112,  72,  80, 253, 237, 185, 218,  94,  21,  70,  87, 167, 141, 157, 132, 144, 216, 171,   0,
                    140, 188, 211,  10, 247, 228,  88,   5, 184, 179,  69,   6, 208,  44,  30, 143, 202,  63,  15,   2,
                    193, 175, 189,   3,   1,  19, 138, 107,  58, 145,  17,  65,  79, 103, 220, 234, 151, 242, 207, 206,
                    240, 180, 230, 115, 150, 172, 116,  34, 231, 173,  53, 133, 226, 249,  55, 232,  28, 117, 223, 110,
                     71, 241,  26, 113,  29,  41, 197, 137, 111, 183,  98,  14, 170,  24, 190,  27, 252,  86,  62,  75,
                    198, 210, 121,  32, 154, 219, 192, 254, 120, 205,  90, 244,  31, 221, 168,  51, 136,   7, 199,  49,
                    177,  18,  16,  89,  39, 128, 236,  95,  96,  81, 127, 169,  25, 181,  74,  13,  45, 229, 122, 159,
                    147, 201, 156, 239, 160, 224,  59,  77, 174,  42, 245, 176, 200, 235, 187,  60, 131,  83, 153,  97,
                     23,  43,   4, 126, 186, 119, 214,  38, 225, 105,  20,  99,  85,  33,  12, 125]


def genTables():
    """
    This function is included for user convenience and understanding.
    Generates the substitution bytes tables for encryption and decryption in AES.
    """
    c = BitVector(bitstring='01100011')
    d = BitVector(bitstring='00000101')
    for i in range(0, 256):
        # For the encryption SBox
        a = BitVector(intVal = i, size=8).gf_MI(AES_modulus, 8) if i != 0 else BitVector(intVal=0)
        # For bit scrambling for the encryption SBox entries:
        a1,a2,a3,a4 = [a.deep_copy() for x in range(4)]
        a ^= (a1 >> 4) ^ (a2 >> 5) ^ (a3 >> 6) ^ (a4 >> 7) ^ c
        subBytesTable.append(int(a))
        # For the decryption Sbox:
        b = BitVector(intVal = i, size=8)
        # For bit scrambling for the decryption SBox entries:
        b1,b2,b3 = [b.deep_copy() for x in range(3)]
        b = (b1 >> 2) ^ (b2 >> 5) ^ (b3 >> 7) ^ d
        check = b.gf_MI(AES_modulus, 8)
        b = check if isinstance(check, BitVector) else 0
        invSubBytesTable.append(int(b))


def state_array_to_bitvector(state_array):
    """
    Changes state array of strings into BitVector values in the format of the word table.
    :param state_array: Traditional array of states for AES
    :return: BitVector form of state array.
    """
    temp_bv = BitVector(intVal=int(state_array[0][0], 0))
    if len(temp_bv) < 8:
        temp_bv.pad_from_left(8 - len(temp_bv) % 8)
    bv = temp_bv
    for j in range(0, 4):
        for i in range(0, 4):
            if i | j:
                temp_bv = BitVector(intVal=int(state_array[i][j], 0))
                if len(temp_bv) < 8:
                    temp_bv.pad_from_left(8-(len(temp_bv)))
                bv = bv + temp_bv
    return bv


def gee(keyword, round_constant, byte_sub_table):
    '''
    This is the g() function you see in Figure 4 of Lecture 8.
    '''
    rotated_word = keyword.deep_copy()
    rotated_word << 8
    newword = BitVector(size = 0)
    for i in range(4):
        newword += BitVector(intVal=byte_sub_table[rotated_word[8*i:8*i+8].intValue()], size=8)
    newword[:8] ^= round_constant
    round_constant = round_constant.gf_multiply_modular(BitVector(intVal=0x02), AES_modulus, 8)
    return newword, round_constant


def gen_key_schedule(key_bv):
    """
    Generates the round keys used for encryption. Each round has its own independent round key that is derived from
    the original 128-bit key. The logic is structured to ensure that one bit changing results in several round keys
    changing as its effect.
    :param key_bv: BitVector version of 128-bit input key
    :return: List of BitVector round keys (12 for AES-128)
    """
    key_words = [None for i in range(44)]
    round_constant = BitVector(intVal=0x01, size=8)
    for i in range(4):
        key_words[i] = key_bv[i*32 : i*32 + 32]
    for i in range(4, 44):
        if i % 4 == 0:
            kwd, round_constant = gee(key_words[i-1], round_constant, subBytesTable)
            key_words[i] = key_words[i-4] ^ kwd
        else:
            key_words[i] = key_words[i-4] ^ key_words[i-1]
    round_keys = [None for _ in range(11)]
    for i in range(11):
        round_keys[i] = BitVector(hexstring=(key_words[i*4] + key_words[i*4+1] + key_words[i*4+2] +
                         key_words[i*4+3]).get_bitvector_in_hex())
    return round_keys


def sub_bytes(state):
    """
    Substitution step for encryption. Utilizes subBytesTable generated as a constant by genTables()
    :param state: 4x4 list of values to look-up
    :return: Lookup translation of 4x4 state array
    """
    for i in range(4):
        for j in range(4):
            state[i][j] = hex(subBytesTable[int(state[i][j], 0)])
    return state


def inv_sub_bytes(state):
    """
    Substitution step for decryption. Utilizes invSubBytesTable generated as a constant by genTables()
    :param state: 4x4 list of values to look-up
    :return: Lookup translation of 4x4 state array
    """
    for i in range(4):
        for j in range(4):
            state[i][j] = hex(invSubBytesTable[int(state[i][j], 16)])
    return state


def shift_rows(state):
    """
    Shift step for encryption. Rotates 2nd, 3rd, and 4th row of 4x4 array by 1, 2, and 3 respectively to the right.
    :param state: 4x4 state array
    :return: Shifted 4x4 state array
    """
    for sh_loc in range(1, 4):
        state[sh_loc] = state[sh_loc][sh_loc:] + state[sh_loc][:sh_loc]
    return state


def inv_shift_rows(state):
    """
    Shift step for decryption. Rotates 2nd, 3rd, and 4th row of 4x4 array by 1, 2, and 3 respectively to the left.
    :param state: 4x4 state array
    :return: Shifted 4x4 state array
    """
    for sh_loc in range(1, 4):
        state[sh_loc] = state[sh_loc][-sh_loc:] + state[sh_loc][:-sh_loc]
    return state


def mix_columns(state):
    """
    Mix function for encryption. Replaces each byte of a column by a function of all the bytes in the same column.
    :param state: 4x4 state array
    :return: Mixed 4x4 state array
    """
    hex02 = BitVector(hexstring='02')
    hex03 = BitVector(hexstring='03')
    dup_state = [[BitVector(size=8) for _ in range(4)] for _ in range(4)]
    for i in range(4):
        for j in range(4):
            state[i][j] = BitVector(intVal=int(state[i][j], 0))
            if len(state[i][j]) < 8:
                state[i][j].pad_from_left(8-len(state[i][j]))
            dup_state[i][j] = state[i][j].deep_copy()
    for i in range(4):
        state[0][i] = dup_state[0][i].gf_multiply_modular(hex02, AES_modulus, 8) \
                      ^ dup_state[1][i].gf_multiply_modular(hex03, AES_modulus, 8) ^ dup_state[2][i] ^ dup_state[3][i]
        state[1][i] = dup_state[0][i] ^ dup_state[1][i].gf_multiply_modular(hex02, AES_modulus, 8) \
                      ^ dup_state[2][i].gf_multiply_modular(hex03, AES_modulus, 8) ^ dup_state[3][i]
        state[2][i] = dup_state[0][i] ^ dup_state[1][i] ^ dup_state[2][i].gf_multiply_modular(hex02, AES_modulus, 8) \
                      ^ dup_state[3][i].gf_multiply_modular(hex03, AES_modulus, 8)
        state[3][i] = dup_state[0][i].gf_multiply_modular(hex03, AES_modulus, 8) ^ dup_state[1][i] ^ dup_state[2][i] \
                      ^ dup_state[3][i].gf_multiply_modular(hex02, AES_modulus, 8)
    for i in range(4):
        for j in range(4):
            state[i][j] = hex(state[i][j].int_val())
    return state


def inv_mix_columns(state):
    """
    Mix function for decryption. Replaces each byte of a column by a function of all the bytes in the same column.
    :param state: 4x4 state array
    :return: Mixed 4x4 state array
    """
    hex0E = BitVector(hexstring='0e')
    hex0B = BitVector(hexstring='0b')
    hex0D = BitVector(hexstring='0d')
    hex09 = BitVector(hexstring='09')
    dup_state = [[BitVector(size=8) for _ in range(4)] for _ in range(4)]
    for i in range(4):
        for j in range(4):
            state[i][j] = BitVector(intVal=int(state[i][j], 0))
            if len(state[i][j]) < 8:
                state[i][j].pad_from_left(8-len(state[i][j]))
            dup_state[i][j] = state[i][j].deep_copy()
    for i in range(4):
        state[0][i] = dup_state[0][i].gf_multiply_modular(hex0E, AES_modulus, 8) ^ \
                      dup_state[1][i].gf_multiply_modular(hex0B, AES_modulus, 8) ^ \
                      dup_state[2][i].gf_multiply_modular(hex0D, AES_modulus, 8) ^ \
                      dup_state[3][i].gf_multiply_modular(hex09, AES_modulus, 8)
        state[1][i] = dup_state[0][i].gf_multiply_modular(hex09, AES_modulus, 8) ^ \
                      dup_state[1][i].gf_multiply_modular(hex0E, AES_modulus, 8) ^ \
                      dup_state[2][i].gf_multiply_modular(hex0B, AES_modulus, 8) ^ \
                      dup_state[3][i].gf_multiply_modular(hex0D, AES_modulus, 8)
        state[2][i] = dup_state[0][i].gf_multiply_modular(hex0D, AES_modulus, 8) ^ \
                      dup_state[1][i].gf_multiply_modular(hex09, AES_modulus, 8) ^ \
                      dup_state[2][i].gf_multiply_modular(hex0E, AES_modulus, 8) ^ \
                      dup_state[3][i].gf_multiply_modular(hex0B, AES_modulus, 8)
        state[3][i] = dup_state[0][i].gf_multiply_modular(hex0B, AES_modulus, 8) ^ \
                      dup_state[1][i].gf_multiply_modular(hex0D, AES_modulus, 8) ^ \
                      dup_state[2][i].gf_multiply_modular(hex09, AES_modulus, 8) ^ \
                      dup_state[3][i].gf_multiply_modular(hex0E, AES_modulus, 8)
    for i in range(4):
        for j in range(4):
            state[i][j] = hex(state[i][j].int_val())
    return state


def aes_encryption(encrypt_key, input_filename, output_filename):
    """
    Primary AES encryption algorithm. Takes a key and and input and encrypts into an output file.
    :param encrypt_key: 16-byte/128-bit encryption key
    :param input_filename: Name of file to be encrypted
    :param output_filename: Name of file to place encrypted output
    """
    # Create vectors for iteration
    key_bv = BitVector(textstring=encrypt_key)
    input_bv = BitVector(filename=input_filename)
    # Output files
    output_file = open(output_filename, 'wb')
    hex_file = open(output_filename+'.hex', 'wb')
    # Initialize empty arrays
    state_array = [[0 for _ in range(4)] for _ in range(4)]
    next_array = [[0 for _ in range(4)] for _ in range(4)]
    # Encryption
    round_keys = gen_key_schedule(key_bv)
    while input_bv.more_to_read:
        bitvec = input_bv.read_bits_from_file(128)  # read 128-bit block
        # Pad to ensure proper length when necessary...
        if bitvec.length() % 128 != 0:
            bitvec.pad_from_right(128 - bitvec.length() % 128)
        bitvec ^= round_keys[0]
        # Generate initial state array configuration
        for i in range(4):
            for j in range(4):
                next_array[j][i] = hex(bitvec[32*i + 8*j:32*i + 8*(j+1)].int_val())
        # Run each round
        for round in range(1, 10):
            state_array = next_array
            state_array = sub_bytes(state_array)
            state_array = shift_rows(state_array)
            state_array = mix_columns(state_array)
            state_array = round_keys[round] ^ state_array_to_bitvector(state_array)
            for i in range(4):
                for j in range(4):
                    next_array[j][i] = hex(state_array[32*i + 8*j:32*i + 8*(j+1)].int_val())
        state_array = sub_bytes(next_array)
        state_array = shift_rows(state_array)
        # state_array = mix_columns(state_array)
        state_array = round_keys[10] ^ state_array_to_bitvector(state_array)
        state_array.write_to_file(output_file)
        hex_file.write(state_array.get_bitvector_in_hex())
    output_file.close()
    hex_file.close()


def aes_decryption(encrypt_key, input_filename, output_filename):
    """
    Primary AES decryption algorithm. Takes a key and and encrypted input and decrypts into an output file.
    :param encrypt_key: 16-byte/128-bit encryption key
    :param input_filename: Name of file to be decrypted
    :param output_filename: Name of file to place decrypted output
    """
    # Create vectors for iteration
    key_bv = BitVector(textstring=encrypt_key)
    input_bv = BitVector(filename=input_filename)
    # Output files
    output_file = open(output_filename, 'wb')
    # Initialize empty arrays
    state_array = [[0 for _ in range(4)] for _ in range(4)]
    next_array = [[0 for _ in range(4)] for _ in range(4)]
    # Encryption
    round_keys = gen_key_schedule(key_bv)
    while input_bv.more_to_read:
        bitvec = input_bv.read_bits_from_file(128)  # read 128-bit block
        # Pad to ensure proper length when necessary...
        if bitvec.length() % 128 != 0:
            bitvec.pad_from_right(128 - bitvec.length() % 128)
        bitvec ^= round_keys[10]
        # Generate initial state array configuration
        for i in range(4):
            for j in range(4):
                next_array[j][i] = hex(bitvec[32*i + 8*j:32*i + 8*(j+1)].int_val())
        for round in range(9, 0, -1):
            state_array = next_array
            state_array = inv_shift_rows(state_array)
            state_array = inv_sub_bytes(state_array)
            state_array = round_keys[round] ^ state_array_to_bitvector(state_array)
            for i in range(4):
                for j in range(4):
                    next_array[j][i] = hex(state_array[32*i + 8*j:32*i + 8*(j+1)].int_val())
            next_array = inv_mix_columns(next_array)
        state_array = inv_shift_rows(next_array)
        state_array = inv_sub_bytes(state_array)
        state_array = key_bv ^ state_array_to_bitvector(state_array)
        state_array.write_to_file(output_file)
    output_file.close()


if __name__ == '__main__':
    input_file = "plaintext.txt"
    encrypted_filename = "encrypted.txt"
    decrypted_filename = "decrypted.txt"
    key_text = "yayboilermakers!"
    try:
        key_text = raw_input("Enter a 16-character (128-bit) encryption key (default: yayboilermakers!): ")
        key_text = "yayboilermakers!" if len(key_text) != 16 else key_text
    except SyntaxError:
        key_text = "yayboilermakers!"
    print("Key being used: " + key_text)
    aes_encryption(key_text, input_file, encrypted_filename)
    aes_decryption(key_text, encrypted_filename, decrypted_filename)


"""
Theory Questions:
1) Determine the following in GF(11):
    a) (3x^4 + 5x^2 + 10) - (8x^4 - 6x^2 + 2x + 1)
        = (3x^4 + 5x^2 + 10) + (3x^4 + 6x^2 + 9x + 10)
        = 6x^4 + 9x + 9
    b) (2x^2 + 4x - 9) * (6x^3 + 3x^2 - 9x + 2)
        = (2x^2 + 4x + 2) * (6x^3 + 3x^2 + 2x + 2)
        = x^5 + 6x^4 + 2x^4 + 4x^3 + x^3 + 8x^2 + 6x^2 + 4x + 8x + 4
        = x^5 + 8x^4 + 5x^3 + 3x^2 + x + 4

2) For the finite field GF(2^3), calculate the following:
    a) (x^2 + x) * (x^2 + x + 1)
        (x^2 + x) * (x^2 + x + 1)
        = x^4 + 2x^3 + 2x^2 + x (mod x^3 + x + 1)
        = 2x^3 + x^2
    b) (x^2 + 1) - (x^2 + x + 1)
        (x^2 + 1) - (x^2 + x + 1)
        = (x^2 + 1) + (7x^2 + 7x + 7)
        = 7x
    c) (x^2 + x + 1) / (x^2)
        = (x^2 + x + 1) * (x^2 + x + 1)
        = x^4 + 2x^3 + 4x^2 + 2x + 1 (mod x^3 + x + 1)
        = 3x^2 + 6

3) For the given bitstreams, calculate the following with respect to the finite field GF(2^3). Use the methods described
in lecture 7 for performing computations with bit patterns. When necessary, use the modulus polynomial (x^3 + x + 1).
Compare answers with the answers obtained in Question 2. Keep in mind the fact that we use the degree terms of the
polynomial only as placeholders for the coefficients. A and B are the two operands.
    NOTE: After discussion with Avi and per Constantine email, these computations can be done with the binomial method.
    a) A = 110 and B = 111. Find A * B.
        (x^2 + x) * (x^2 + x + 1)
        = x^4 + 2x^3 + 2x^2 + x (mod x^3 + x + 1)
        = 2x^3 + x^2
    b) A = 101 and B = 111. Find A - B.
        (x^2 + 1) - (x^2 + x + 1)
        = (x^2 + 1) + (7x^2 + 7x + 7)
        = 7x
    c) A = 111 and B = 100. Find A / B.
        (x^2 + x + 1) / (x^2)
        = (x^2 + x + 1) * (x^2 + x + 1)
        = x^4 + 2x^3 + 4x^2 + 2x + 1 (mod x^3 + x + 1)
        = 3x^2 + 6
"""
